你现在这波“一直报错”，本质是**两类问题叠加**：

1. **类型没定义**（`int64`）→ 直接编译失败。
2. **函数声明/定义不一致**（或根本没声明）→ `implicit declaration` / `conflicting types` 轮番上阵。([CSDN][1])

下面按“只给修改点前后对比”的方式给你一套**能把当前报错压下去**的改法（同时把你之前那几个 `uvminit/uvmalloc/uvmcopy` 冲突一并根治）。

---

## 1) 修复 `int64` 未定义（根因：xv6 里通常只有 `uint64`，你用的 `int64` 没 typedef）

**文件：`kernel/include/types.h`**（或你项目里定义 `uint64` 的那个 types.h）

```diff
@@
 typedef unsigned long uint64;
+typedef long int64;
```

> 这样 `sys_sbrk` 里的 `(int64)n` 才有意义，不然就像你现在这样直接炸。

---

## 2) 修复 `sys_sbrk()`：用“有符号中间值”做溢出/下溢检查 + shrink 才调用 `uvmdealloc`

你当前错误点在这里：`(int64)n`。修了 typedef 还不够，**写法也建议换**，避免 `uint64` 先参与运算导致诡异溢出。

**文件：`kernel/sysproc.c`**（函数 `sys_sbrk`）

```diff
@@
 uint64
 sys_sbrk(void)
 {
   int n;
   argint(0, &n);
   struct proc *p = myproc();
   uint64 oldsz = p->sz;
-  uint64 newsz = oldsz + (int64)n;
-  if((int64)newsz < 0)
-    return -1;
-  p->sz = uvmdealloc(p->pagetable, p->kpagetable, oldsz, newsz);
+  int64 ns = (int64)oldsz + (int64)n;
+  if(ns < 0 || ns > (int64)MAXUVA)
+    return -1;
+  uint64 newsz = (uint64)ns;
+
+  if(n < 0){
+    p->sz = uvmdealloc(p->pagetable, p->kpagetable, oldsz, newsz);
+  } else {
+    // lazy alloc：只涨 sz，不在 sbrk 里实际分配页
+    p->sz = newsz;
+  }
   return oldsz;
 }
```

---

## 3) 修复 `uvmdealloc` “implicit declaration”：给它补声明，并统一签名（避免下一轮 `conflicting types`）

你现在编译器提示：`uvmdealloc` 未声明（于是按 C99 规则会报/警告）。([CSDN][1])
而你又在 `sys_sbrk` 里按“两页表版本”调用：`uvmdealloc(pagetable, kpagetable, ...)`
所以必须在**所有声明处统一**。

### 3.1 `kernel/include/defs.h`

找到原来的 uvm 系列声明，改成和你 vm.h 一致（你之前报的冲突就是这里没改）

```diff
@@
-void            uvminit(pagetable_t, uchar *, uint);
-uint64          uvmalloc(pagetable_t, uint64, uint64);
-int             uvmcopy(pagetable_t, pagetable_t, uint64);
+void            uvminit(pagetable_t, pagetable_t, uchar *, uint);
+uint64          uvmalloc(pagetable_t, pagetable_t, uint64, uint64);
+int             uvmcopy(pagetable_t, pagetable_t, pagetable_t, uint64);
+uint64          uvmdealloc(pagetable_t, pagetable_t, uint64, uint64);
+int             is_cow_page(pagetable_t, uint64);
```

### 3.2 `kernel/include/vm.h`

如果 vm.h 里已经是“两页表签名”，那就只补缺的；如果还没统一，就按下面对齐：

```diff
@@
 void            uvminit(pagetable_t, pagetable_t, uchar *, uint);
 uint64          uvmalloc(pagetable_t, pagetable_t, uint64, uint64);
 int             uvmcopy(pagetable_t, pagetable_t, pagetable_t, uint64);
+uint64          uvmdealloc(pagetable_t, pagetable_t, uint64, uint64);
+int             is_cow_page(pagetable_t, uint64);
```

> 关键原则：**同一个函数的原型只能有一种签名**。你之前 `uvminit/uvmalloc/uvmcopy` 的冲突，就是 defs.h 还留着旧签名。

---

## 4) 在 `kernel/vm.c` 里把 `uvmdealloc` 真正改成“两页表版本”（并且避免 double-free）

如果你已经改过但签名还没对齐，按下面改。重点是：

* 用户页表 `uvmunmap(..., do_free=1)` 释放物理页
* 内核页表只是解除映射 `do_free=0`，否则会二次释放

**文件：`kernel/vm.c`**

```diff
@@
-uint64
-uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+uint64
+uvmdealloc(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz)
 {
   if(newsz >= oldsz)
     return oldsz;

   uint64 a = PGROUNDUP(newsz);
   if(a  < PGROUNDUP(oldsz)){
     int npages = (PGROUNDUP(oldsz) - a) / PGSIZE;
-    uvmunmap(pagetable, a, npages, 1);
+    uvmunmap(pagetable,  a, npages, 1); // free PA
+    uvmunmap(kpagetable, a, npages, 0); // only unmap
   }
   return newsz;
 }
```

---

## 5) 顺手灭掉 `is_cow_page` 的隐式声明 warning（不然下一步你会被 warning 海淹没）

你现在 `trap.c`：`is_cow_page` implicit declaration。原因同上：**没在头文件声明**。([CSDN][1])
上面我已经让你在 `defs.h/vm.h` 补了原型。接下来确保 vm.c 里真有定义（没有就加）：

**文件：`kernel/vm.c`**（找个合适位置加）

```diff
@@
+int
+is_cow_page(pagetable_t pagetable, uint64 va)
+{
+  pte_t *pte = walk(pagetable, va, 0);
+  if(pte == 0) return 0;
+  if((*pte & PTE_V) == 0) return 0;
+  return (*pte & PTE_COW) != 0;
+}
```

> `PTE_COW` 你既然已经在用 COW 逻辑，项目里应该已定义；没定义那是另一处问题（但你现在的日志显示 COW 相关代码已在跑）。

---

## 6) 你之前 `./run.bash: cannot execute: required file not found`（可选修复）

这个通常是 **CRLF 行尾** 或 shebang 不对导致的（WSL 很常见）。你现在能跑了就先不管；如果再出现：

```bash
sudo apt-get install -y dos2unix
dos2unix run.bash
chmod +x run.bash
```

---

## 最短落地路径（按这个顺序改，报错会明显收敛）

1. `types.h` 加 `typedef long int64;`
2. 按第 2 节改 `sys_sbrk`
3. 同步 `defs.h` 与 `vm.h` 里 `uvminit/uvmalloc/uvmcopy/uvmdealloc/is_cow_page` 原型
4. vm.c 改 `uvmdealloc` 两页表版本
5. `make clean && make run`

如果你照做后还有**新的第一条 error**，把“从第一条 error 开始往下 30 行”贴出来（不用全日志），我继续按“前后对比补丁”的方式给你压下去。

[1]: https://blog.csdn.net/cnwyt/article/details/105073749 "C编译报错: implicit declaration of function xxx is invalid in C99 [-Wimplicit-function-declaration]_implicit declaration of function is invalid in c99-CSDN博客"
